name: PhaseHound simple release

on:
  workflow_dispatch:
    inputs:
      set_name:
        description: 'Release name (optional). If empty → PhaseHound-unmarked-<sha7>'
        required: false
        type: string

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: ubuntu-latest

    env:
      BUILD_DIR: dist

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install deps
        run: |
          set -eux
          sudo apt-get update
          sudo apt-get install -y build-essential pkg-config libsoapysdr-dev libasound2-dev

      - name: Build
        run: |
          set -eux
          make -j"$(nproc)"

      - name: Assemble release skeleton
        run: |
          set -euo pipefail
          rm -rf "$BUILD_DIR"
          mkdir -p "$BUILD_DIR/addons"

          # Pick up binaries (root or shallow dirs)
          CORE_PATH="$(find . -maxdepth 2 -type f -name ph-core -perm -111 | head -n1 || true)"
          CLI_PATH="$(find . -maxdepth 2 -type f -name ph-cli  -perm -111 | head -n1 || true)"
          [ -n "${CORE_PATH:-}" ] && install -m 0755 "$CORE_PATH" "$BUILD_DIR/ph-core" || echo "WARN: ph-core not found"
          [ -n "${CLI_PATH:-}"  ] && install -m 0755 "$CLI_PATH"  "$BUILD_DIR/ph-cli"  || echo "WARN: ph-cli not found"

          # src/addons/<name>/*.so  →  ./addons/<name>/ph-lib<name>.so
          if [ -d src/addons ]; then
            for d in src/addons/*; do
              [ -d "$d" ] || continue
              name="$(basename "$d")"
              so="$(find "$d" -maxdepth 1 -type f -name '*.so' | head -n1 || true)"
              if [ -n "${so:-}" ]; then
                mkdir -p "$BUILD_DIR/addons/$name"
                cp "$so" "$BUILD_DIR/addons/$name/ph-lib${name}.so"
              fi
            done
          fi

          echo "Release tree:"
          find "$BUILD_DIR" -type f | sort

      - name: Name release & archive
        id: meta
        run: |
          set -euo pipefail
          shortsha="${GITHUB_SHA::7}"
          REL_NAME="${{ inputs.set_name }}"
          if [ -z "$REL_NAME" ]; then
            REL_NAME="PhaseHound-unmarked-${shortsha}"
          fi
          # internal tag (not an input) required by GitHub; keep it boring/unique
          TAG="auto-${shortsha}"
          ARCHIVE="phasehound-${shortsha}-linux-amd64.tar.gz"

          echo "rel_name=$REL_NAME" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG"           >> "$GITHUB_OUTPUT"
          echo "archive=$ARCHIVE"   >> "$GITHUB_OUTPUT"

          echo "REL_NAME=$REL_NAME" >> "$GITHUB_ENV"
          echo "TAG=$TAG"           >> "$GITHUB_ENV"
          echo "ARCHIVE=$ARCHIVE"   >> "$GITHUB_ENV"

      - name: Package tarball (+ checksum)
        run: |
          set -eux
          tar -C "$BUILD_DIR" -czf "$ARCHIVE" .
          sha256sum "$ARCHIVE" > "$ARCHIVE.sha256"

      - name: Upload CI artifact (optional)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.meta.outputs.rel_name }}
          path: |
            ${{ env.ARCHIVE }}
            ${{ env.ARCHIVE }}.sha256
          retention-days: 7

      - name: Publish GitHub Release (no local tagging)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Release title decided earlier into $REL_NAME, archive path in $ARCHIVE
          shortsha="${GITHUB_SHA::7}"
          TAG="auto-${shortsha}"
      
          # If the release doesn't exist, create it and point the tag at this commit
          if ! gh release view "$TAG" >/dev/null 2>&1; then
            gh release create "$TAG" "$ARCHIVE" "$ARCHIVE.sha256" \
              --title "$REL_NAME" \
              --notes "Automated build and packaging." \
              --target "$GITHUB_SHA"
          else
            gh release upload "$TAG" "$ARCHIVE" "$ARCHIVE.sha256" --clobber
            gh release edit "$TAG" --title "$REL_NAME"
          fi
